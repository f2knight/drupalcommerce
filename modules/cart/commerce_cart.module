<?php
// $Id$

/**
 * @file
 * Implements the shopping cart system and add to cart features.
 *
 * In Drupal Commerce, the shopping cart is really just an order that makes
 * special considerations to associate it with a user and
 */


/**
 * Implements hook_menu().
 */
function commerce_cart_menu() {
  $items = array();

  $items['cart'] = array(
    'title' => 'Shopping cart',
    'page callback' => 'commerce_cart_view',
    'access arguments' => array('access content'),
    'file' => 'includes/commerce_cart.pages.inc',
  );

  $items['checkout'] = array(
    'title' => 'Checkout',
    'page callback' => 'commerce_cart_checkout_router',
    'access arguments' => array('access checkout'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_cart.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_commerce_order_state_info().
 */
function commerce_cart_commerce_order_state_info() {
  $order_states = array();

  $order_states['cart'] = (object) array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'description' => t('Orders in this state have not been completed by the customer yet.'),
    'weight' => -5,
    'default_status' => 'cart',
  );

  return $order_states;
}

/**
 * Implements hook_commerce_order_status_info().
 */
function commerce_cart_commerce_order_status_info() {
  $order_statuses = array();

  $order_statuses['cart'] = (object) array(
    'name' => 'cart',
    'title' => t('Shopping cart'),
    'state' => 'cart',
    'cart' => TRUE,
  );

  return $order_statuses;
}

/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_cart_commerce_checkout_pane_info() {
  $checkout_panes = array();

  $checkout_panes['cart_contents'] = (object) array(
    'title' => t('Shopping cart contents'),
    'base' => 'commerce_cart_contents_pane',
    'file' => 'includes/commerce_cart.checkout_pane.inc',
    'page' => 'checkout',
  );

  return $checkout_panes;
}

/**
 * Implements hook_commerce_checkout_complete().
 */
function commerce_cart_commerce_checkout_complete($order) {
  // Move the cart order ID to a completed order ID.
  if (commerce_cart_order_session_exists($order->order_id)) {
    commerce_cart_order_session_save($order->order_id, TRUE);
    commerce_cart_order_session_delete($order->order_id);
  }
}

/**
 * Implements hook_commerce_line_item_summary_link_info().
 */
function commerce_cart_commerce_line_item_summary_link_info() {
  return array(
    'view_cart' => array(
      'title' => t('View cart'),
      'href' => 'cart',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 0,
    ),
    'checkout' => array(
      'title' => t('Checkout'),
      'href' => 'checkout',
      'attributes' => array('rel' => 'nofollow'),
      'weight' => 5,
      'access' => user_access('access checkout'),
    ),
  );
}

/**
 * Implements hook_form_alter().
 */
function commerce_cart_form_alter(&$form, &$form_values, $form_id) {
  if (strpos($form_id, 'commerce_line_item_views_form_commerce_cart_form_') === 0) {
    // Change the Save button to say Update cart.
    $form['actions']['update']['#value'] = t('Update cart');
    $form['actions']['update']['#submit'] = array_merge($form['#submit'], array('commerce_cart_line_item_views_form_submit'));

    // Change any Delete buttons to say Remove.
    if (!empty($form['edit_delete'])) {
      foreach(element_children($form['edit_delete']) as $line_item_id) {
        $form['edit_delete'][$line_item_id]['#value'] = t('Remove');
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 * This form alters ensures that administrators can't try to alter orders in cart
 * statuses.
 * @see commerce_cart_commerce_order_load.
 */
function commerce_cart_form_commerce_order_ui_order_form_alter(&$form, &$form_values, $form_id) {
  $order = $form_values['commerce_order'];
  if (in_array($order->status, array_keys(commerce_order_statuses(array('cart' => TRUE))))) {
    foreach ($form['line_items'][LANGUAGE_NONE]['line_items'] as &$line_item) {
      $line_item['unit_price'][LANGUAGE_NONE][0]['amount']['#disabled'] = 'true';
      $line_item['unit_price'][LANGUAGE_NONE][0]['currency_code']['#disabled'] = 'true';
    }
  }
}

/**
 * Submit handler to show the shopping cart updated message.
 */
function commerce_cart_line_item_views_form_submit($form, &$form_state) {
  drupal_set_message(t('Your shopping cart has been updated.'));
}

/**
 * Implements hook_commerce_order_delete().
 */
function commerce_cart_commerce_order_delete($order) {
  commerce_cart_order_session_delete($order->order_id);
  commerce_cart_order_session_delete($order->order_id, TRUE);
}

/**
 * Implements hook_views_api().
 */
function commerce_cart_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'commerce_cart') . '/includes/views',
  );
}

/**
 * Implements hook_theme().
 */
function commerce_cart_theme() {
  return array(
    'commerce_cart_empty_block' => array(
      'variables' => array(),
    ),
    'commerce_cart_empty_page' => array(
      'variables' => array(),
    ),
    'commerce_cart_block' => array(
      'variables' => array('order' => NULL, 'contents_view' => NULL),
      'path' => drupal_get_path('module', 'commerce_cart') . '/theme',
      'template' => 'commerce-cart-block',
    ),
  );
}

/**
 * Implements hook_user_login().
 */
function commerce_cart_user_login(&$edit, $account) {
  // Merge any items in the anonymous cart with the authenticated user's cart.

  // Get the anonymous cart if it exists.
  if ($anonymous_order = commerce_cart_order_load()) {
    // If the anonymous user had any items in the cart, add them to the user's
    // authenticated cart.
    if (!empty($anonymous_order->line_items[LANGUAGE_NONE])) {
      // Add each of the anonymous cart items to the authenticated user's cart.
      $line_item_ids = array();

      foreach ($anonymous_order->line_items[LANGUAGE_NONE] as $line_item_reference) {
        $line_item_ids[] = $line_item_reference['line_item_id'];
      }

      foreach (commerce_line_item_load_multiple($line_item_ids) as $line_item) {
        commerce_cart_product_add($account->uid, $line_item->product[LANGUAGE_NONE][0]['product_id'], $line_item->quantity);
      }

      // Delete the anonymous order from the database and clear the reference.
      commerce_order_delete($anonymous_order->order_id);
    }
  }

  // Set the uid for any completed orders if they exist.
  if (commerce_cart_order_session_exists(NULL, TRUE)) {
    foreach (commerce_cart_order_session_order_ids(TRUE) as $order_id) {
      if ($order = commerce_order_load($order_id)) {
        if ($order->uid == 0) {
          $order->uid = $account->uid;
          commerce_order_save($order);
        }
      }
    }

    commerce_cart_order_session_delete(NULL, TRUE);
  }
}

/**
 * Implements hook_block_info().
 */
function commerce_cart_block_info() {
  $blocks = array();

  // Define the basic shopping cart block and hide it on the checkout pages.
  $blocks['cart'] = array(
    'info' => t('Shopping cart'),
    'cache' => DRUPAL_NO_CACHE,
    'visibility' => 0,
    'pages' => 'checkout*',
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function commerce_cart_block_view($delta) {
  global $user;

  // Prepare the display of the default Shopping Cart block.
  if ($delta == 'cart') {
    // First check for items in the shopping cart.
    $order = commerce_cart_order_load($user->uid);

    // If the cart is empty...
    if (!$order || empty($order->line_items)) {
      // Display an appropriate message.
      $content = theme('commerce_cart_empty_block');
    }
    else {
      // Build the variables array to send to the cart block template.
      $variables = array(
        'order' => $order,
        'contents_view' => commerce_embed_view('commerce_cart_block', 'defaults', array($order->order_id)),
      );

      $content = theme('commerce_cart_block', $variables);
    }

    return array('subject' => t('Shopping cart'), 'content' => $content);
  }
}

/**
 * Implements hook_commerce_order_load().
 *
 * Because shopping carts are merely a special case of orders, we work through
 * the Order API to ensure that products in shopping carts are kept up to date.
 * Therefore, each time a cart is loaded, we calculate afresh the unit and total
 * prices of product line items and save them if any values have changed.
 */
function commerce_cart_commerce_order_load($orders) {
  foreach ($orders as $order) {
    if (in_array($order->status, array_keys(commerce_order_statuses(array('cart' => TRUE))))) {
      $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

      // Loop over every line item on the order...
      $unchanged_line_items = array();

      foreach ($order_wrapper->line_items as $delta => $line_item_wrapper) {
        // If the line item is a product line item...
        if ($line_item_wrapper->type->value() == 'product') {
          // Create a new product line item referencing the same product as though
          // we had not added it to the cart yet, but use the current quantity.
          $line_item = commerce_product_line_item_new($line_item_wrapper->product->value(), $line_item_wrapper->quantity->value());

          // Process the unit price through Rules so it reflects the user's actual
          // current purchase price.
          rules_invoke_event('commerce_product_calculate_sell_price', $line_item);
        }
        else {
          $line_item = clone($line_item_wrapper->value());
        }

        // Allow other modules alter line items on a shopping cart refresh.
        module_invoke_all('commerce_cart_line_item_refresh', $line_item, $order_wrapper);

        // Compare the refreshed unit price to the original unit price.
        $current_line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

        if ($line_item_wrapper->unit_price->amount->value() != $current_line_item_wrapper->unit_price->amount->value() ||
          $line_item_wrapper->unit_price->currency_code->value() != $current_line_item_wrapper->unit_price->currency_code->value()) {
          // Adjust the unit price accordingly if necessary.
          $line_item_wrapper->unit_price->amount = $current_line_item_wrapper->unit_price->amount->value();
          $line_item_wrapper->unit_price->currency_code = $current_line_item_wrapper->unit_price->currency_code->value();

          // Save the updated line item; for some reason I have to call both
          // of these functions for the changes to be fully evident on the
          // current pageload. It could just be a static caching issue.
          commerce_line_item_save($line_item_wrapper->value());
          $line_item_wrapper->save();
        }
      }

      // Allow other modules to alter the entire order on a shopping cart refresh.
      module_invoke_all('commerce_cart_order_refresh', $order_wrapper);
    }
  }
}

/**
 * Implements hook_commerce_order_presave().
 *
 * Resets the shopping cart order status when the cart contents are changed,
 * which we check on order save by seeing if line items are added or removed.
 */
function commerce_cart_commerce_order_presave($order) {
  // Create an array of shopping cart order statuses we need to monitor.
  $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

  // Exit if this is a new order or not in a cart status.
  if (empty($order->order_id) || !in_array($order->status, $status_ids)) {
    return;
  }

  $wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Get the order directly from the database and compare with the current one.
  $unchanged_order = reset(commerce_order_load_multiple(array($order->order_id), array(), TRUE));
  $unchanged_wrapper = entity_metadata_wrapper('commerce_order', $unchanged_order);

  // If the number of line items has changed, reset the status.
  if (count($unchanged_wrapper->line_items) != count($wrapper->line_items)) {
    $order->status = 'cart';
  }
  else {
    // Otherwise compare the actual line item IDs.
    $unchanged_line_item_ids = array();

    foreach ($unchanged_wrapper->line_items as $key => $value) {
      $unchanged_line_item_ids[] = $key;
    }

    foreach ($wrapper->line_items as $key => $value) {
      if (!in_array($key, $unchanged_line_item_ids)) {
        $order->status = 'cart';
      }
    }
  }
}

/**
 * Implements hook_commerce_line_item_presave().
 *
 * Resets the pertinent shopping cart order status when line items are changed,
 * which we check on line item save.
 */
function commerce_cart_commerce_line_item_presave($line_item) {
  // Exit now if the line item is being inserted for the first time, as it won't
  // be referenced by an order yet.
  if (empty($line_item->line_item_id)) {
    return;
  }

  // Get the line item directly from the database and compare with the current one.
  $unchanged_line_item = reset(commerce_line_item_load_multiple(array($line_item->line_item_id), array(), TRUE));

  // If the quantity has changed, find any orders that reference this line item.
  if ($unchanged_line_item->quantity != $line_item->quantity) {
    // Create an array of shopping cart order statuses we need to monitor.
    $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

    $query = new EntityFieldQuery();

    $query
      ->entityCondition('entity_type', 'commerce_order')
      ->fieldCondition('line_items', 'line_item_id', $line_item->line_item_id, '=')
      ->execute();

    foreach ($query->ordered_results as $entity) {
      $order = commerce_order_load($entity->entity_id);

      if (in_array($order->status, $status_ids)) {
        $order->status = 'cart';
        commerce_order_save($order);
      }
    }
  }
}

/**
 * Implements hook_commerce_line_item_delete().
 *
 * Resets the pertinent shopping cart order status when a line item is deleted.
 */
function commerce_cart_commerce_line_item_delete($line_item) {
  // Create an array of shopping cart order statuses we need to monitor.
  $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

  $query = new EntityFieldQuery();

  // Look for any order referencing this line item.
  $result = $query
    ->entityCondition('entity_type', 'commerce_order')
    ->fieldCondition('line_items', 'line_item_id', $line_item->line_item_id, '=')
    ->execute();

  // If we received a result set...
  if (!empty($result['commerce_order'])) {
    // Loop through each item that we found.
    foreach (commerce_order_load_multiple(array_keys($result['commerce_order'])) as $order) {
      // If the current order's status is a shopping cart order status...
      if (in_array($order->status, $status_ids)) {
        // Reset the order to the Cart status directly.
        $order->status = 'cart';
        commerce_order_save($order);
      }
    }
  }
}

/**
 * Themes an empty shopping cart block's contents.
 */
function theme_commerce_cart_empty_block() {
  return '<div class="cart-empty-block">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Themes an empty shopping cart page.
 */
function theme_commerce_cart_empty_page() {
  return '<div class="cart-empty-page">' . t('Your shopping cart is empty.') . '</div>';
}

/**
 * Loads the shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the customer whose cart to load. If left 0, attempts to load
 *     an anonymous order from the session.
 *
 * @return
 *   The fully loaded shopping cart order or FALSE if non-existent.
 */
function commerce_cart_order_load($uid = 0) {
  // Loaded orders will be cached keyed by $uid.
  $cart_orders = &drupal_static(__FUNCTION__);

  // First return the cached order if it has been loaded already.
  if (!isset($cart_orders[$uid])) {
    $order_id = FALSE;

    // Create an array of valid shopping cart order statuses.
    $status_ids = array_keys(commerce_order_statuses(array('cart' => TRUE)));

    // If a customer uid was specified...
    if ($uid) {
      // Look for the user's most recent shopping cart order, although they
      // should never really have more than one.
      $order_id = db_query('SELECT order_id FROM {commerce_order} WHERE uid = :uid AND status IN (:status_ids) ORDER BY order_id DESC', array(':uid' => $uid, ':status_ids' => $status_ids))->fetchField();
    }
    else {
      // Otherwise look for a shopping cart order ID in the session.
      if (commerce_cart_order_session_exists()) {
        $order_id = db_query('SELECT order_id FROM {commerce_order} WHERE order_id IN (:order_ids) AND status IN (:status_ids) ORDER BY order_id DESC', array(':order_ids' => commerce_cart_order_session_order_ids(), ':status_ids' => $status_ids))->fetchField();
      }
    }

    // If a valid order ID was found, load the order now.
    if ($order_id) {
      $cart_orders[$uid] = commerce_order_load($order_id);
    }
    else {
      $cart_orders[$uid] = FALSE;
    }
  }

  return $cart_orders[$uid];
}

/**
 * Resets the cached array of shopping cart orders.
 */
function commerce_cart_orders_reset() {
  $cart_orders = &drupal_static('commerce_cart_order_load');
  $cart_orders = NULL;
}

/**
 * Creates a new shopping cart order for the specified user.
 *
 * @param $uid
 *   The uid of the user for whom to create the order. If left 0, the order will
 *     be created for the current user and associated with his or her session.
 *
 * @return
 *   The newly created shopping cart order object.
 */
function commerce_cart_order_new($uid = 0) {
  // Create the new order with the customer's uid and the cart order status.
  $order = commerce_order_new($uid, 'cart');
  $order->log = t('Created as a shopping cart order.');

  // Save it so it gets an order ID and return the full object.
  $order = commerce_order_save($order);

  // Reset the cart cache
  commerce_cart_orders_reset();

  // If the user is not logged in, ensure the order ID is stored in the session.
  if (!$uid) {
    commerce_cart_order_session_save($order->order_id);
  }

  return $order;
}

/**
 * Entity metadata callback: returns the current user's shopping cart order.
 *
 * @see commerce_cart_entity_property_info_alter()
 */
function commerce_cart_get_properties($data = FALSE, array $options, $name) {
  global $user;

  switch ($name) {
    case 'current_cart_order':
      if ($order = commerce_cart_order_load($user->uid)) {
        return $order;
      }
      else {
        return commerce_order_new($user->uid, 'cart');
      }
  }
}

/**
 * Returns an array of cart order IDs stored in the session.
 *
 * @param $completed
 *   Boolean indicating whether or not the operation should save to the
 *     completed orders array instead of the active cart orders array.
 *
 * @return
 *   An array of applicable cart order IDs or an empty array if none exist.
 */
function commerce_cart_order_session_order_ids($completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';
  return empty($_SESSION[$key]) ? array() : $_SESSION[$key];
}

/**
 * Saves an order ID to the appropriate cart orders session variable.
 *
 * @param $order_id
 *   The order ID to save to the array.
 * @param $completed
 *   Boolean indicating whether or not the operation should save to the
 *     completed orders array instead of the active cart orders array.
 */
function commerce_cart_order_session_save($order_id, $completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';

  if (empty($_SESSION[$key])) {
    $_SESSION[$key] = array($order_id);
  }
  elseif (!in_array($order_id, $_SESSION[$key])) {
    $_SESSION[$key][] = $order_id;
  }
}

/**
 * Checks to see if any order ID or a specific order ID exists in the session.
 *
 * @param $order_id
 *   Optionally specify an order ID to look for in the commerce_cart_orders
 *     session variable; defaults to NULL.
 * @param $completed
 *   Boolean indicating whether or not the operation should look in the
 *     completed orders array instead of the active cart orders array.
 *
 * @return
 *   Boolean indicating whether or not any cart order ID exists in the session
 *     or if the specified order ID exists in the session.
 */
function commerce_cart_order_session_exists($order_id = NULL, $completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';

  // If an order was specified, look for it in the array.
  if (!empty($order_id)) {
    return !empty($_SESSION[$key]) && in_array($order_id, $_SESSION[$key]);
  }
  else {
    // Otherwise look for any value.
    return !empty($_SESSION[$key]);
  }
}

/**
 * Deletes all order IDs or a specific order ID from the cart orders session
 *   variable.
 *
 * @param $order_id
 *   The order ID to remove from the array or NULL to delete the variable.
 * @param $completed
 *   Boolean indicating whether or not the operation should delete from the
 *     completed orders array instead of the active cart orders array.
 */
function commerce_cart_order_session_delete($order_id = NULL, $completed = FALSE) {
  $key = $completed ? 'commerce_cart_completed_orders' : 'commerce_cart_orders';

  if (!empty($_SESSION[$key])) {
    if (!empty($order_id)) {
      $_SESSION[$key] = array_diff($_SESSION[$key], array($order_id));
    }
    else {
      unset($_SESSION[$key]);
    }
  }
}

/**
 * Adds the specified product to a customer's shopping cart.
 *
 * @param $uid
 *   The uid of the user whose cart you are adding the product to.
 * @param $product_id
 *   The ID of the product to add to the cart.
 * @param $quantity
 *   The quantity of this product to add to the cart.
 *
 * @return
 *   The entire shopping cart order object or FALSE on failure.
 */
function commerce_cart_product_add($uid, $product_id, $quantity) {
  // Load and validate the specified product ID.
  $product = commerce_product_load($product_id);

  // Fail if the product does not exist or is disabled.
  if (empty($product) || !$product->status) {
    return FALSE;
  }

  // First attempt to load the customer's shopping cart order.
  $order = commerce_cart_order_load($uid);

  // If no order existed, create one now.
  if (empty($order)) {
    $order = commerce_cart_order_new($uid);
  }

  // Invoke the product prepare event with the shopping cart order.
  rules_invoke_all('commerce_cart_product_prepare', $order, $product, $quantity);

  // Determine if the product already exists on the order and increment its
  // quantity instead of adding a new line if it does.
  $line_item_match = NULL;

  // If the order has line items on it...
  if (!empty($order->line_items)) {
    $line_item_ids = array();

    // Build an array of the line item IDs.
    foreach ($order->line_items[LANGUAGE_NONE] as $line_item_reference) {
      $line_item_ids[] = $line_item_reference['line_item_id'];
    }

    // Loop through the line items looking for products.
    foreach (commerce_line_item_load_multiple($line_item_ids) as $line_item) {
      // If this line item matches the product being added...
      if (empty($line_item_match) &&
          $line_item->type == 'product' &&
          $line_item->product[LANGUAGE_NONE][0]['product_id'] == $product_id) {
        // Exit this loop with the $line_item intact so it gets updated.
        $line_item_match = clone($line_item);
      }
    }
  }

  // If no matching line item was found...
  if (empty($line_item_match)) {
    // Create the new product line item.
    $line_item = commerce_product_line_item_new($product, $quantity);

    // Process the unit price through Rules so it reflects the user's actual
    // purchase price.
    rules_invoke_event('commerce_product_calculate_sell_price', $line_item);

    // Save the line item now so we get its ID.
    $line_item = commerce_line_item_save($line_item);

    // Add it to the order's line item reference value.
    $order->line_items[LANGUAGE_NONE][] = array(
      'line_item_id' => $line_item->line_item_id,
    );

    // Save the updated order.
    commerce_order_save($order);

    // Invoke the product add event with the newly saved line item.
    rules_invoke_all('commerce_cart_product_add', $order, $product, $quantity, $line_item);
  }
  else {
    // Increment the quantity of the line item and save it.
    $line_item_match->quantity += $quantity;

    commerce_line_item_save($line_item_match);

    // Invoke the product add event with the updated line item.
    // TODO: Debug why the updated quantity isn't available to Rules when
    // iterating over $order->line_items.
    rules_invoke_all('commerce_cart_product_add', $order, $product, $quantity, $line_item_match);
  }

  // Return the order.
  return $order;
}

/**
 * Deletes a product line item from a shopping cart order.
 *
 * @param $order
 *   The shopping cart order to delete from.
 * @param $line_item_id
 *   The ID of the product line item to delete from the order.
 * @param $skip_save
 *   TRUE to skip saving the order after deleting the line item; used when the
 *     order would otherwise be saved or to delete multiple product line items
 *     from the order and then save.
 *
 * @return
 *   The order with the matching product line item deleted from the line_items
 *     reference field.
 */
function commerce_cart_order_product_line_item_delete($order, $line_item_id, $skip_save = FALSE) {
  $line_item = commerce_line_item_load($line_item_id);

  // Check to ensure the line item exists and is a product line item.
  if (!$line_item || $line_item->type != 'product') {
    return $order;
  }

  // Remove the line item from the line item reference field.
  $order = commerce_line_item_reference_delete('commerce_order', $order, 'line_items', $line_item_id);

  // Wrap the line item to be deleted and extract the product from it.
  $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $product = $wrapper->product->value();

  // Invoke the product removal event with the line item about to be deleted.
  rules_invoke_all('commerce_cart_product_remove', $order, $product, $line_item->quantity, $line_item);

  // Delete the actual line item.
  commerce_line_item_delete($line_item->line_item_id);

  return $skip_save ? $order : commerce_order_save($order);
}

/**
 * Deletes every product line item from a shopping cart order.
 *
 * @param $order
 *   The shopping cart order to empty.
 *
 * @return
 *   The order with the product line items all removed.
 */
function commerce_cart_order_empty($order) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Build an array of product line item IDs.
  $line_item_ids = array();

  foreach ($order_wrapper->line_items as $delta => $line_item_wrapper) {
    if ($line_item_wrapper->type->value() == 'product') {
      $line_item_ids[] = $line_item_wrapper->line_item_id->value();
    }
  }

  // Delete each line item one by one from the order. This is done this way
  // instead of unsetting each as we find it to ensure that changing delta
  // values don't prevent an item from being removed from the order.
  foreach ($line_item_ids as $line_item_id) {
    $order = commerce_cart_order_product_line_item_delete($order, $line_item_id, TRUE);
  }

  return commerce_order_save($order);
}

/**
 * Builds an appropriate cart form ID based on the products on the form.
 *
 * @see commerce_cart_forms().
 */
function commerce_cart_add_to_cart_form_id($product_ids, $qty = 0) {
  // Make sure the length of the form id is limited.
  $data = implode('_', $product_ids);

  if (strlen($data) > 50) {
    $data = drupal_hash_base64($data);
  }

  return 'commerce_cart_add_to_cart_form_' . $data;
}

/**
 * Implements hook_forms().
 *
 * To provide distinct form IDs for add to cart forms, the product IDs
 * referenced by the form are appended to the base ID,
 * commerce_cart_add_to_cart_form. When such a form is built or submitted, this
 * function will return the proper callback function to use for the given form.
 */
function commerce_cart_forms($form_id, $args) {
  $forms = array();

  // Construct a valid cart form ID from the arguments.
  if (strpos($form_id, 'commerce_cart_add_to_cart_form_') === 0) {
    $forms[$form_id] = array(
      'callback' => 'commerce_cart_add_to_cart_form',
    );
  }

  return $forms;
}

/**
 * Builds an Add to Cart form for a set of products.
 *
 * @param $product_ids
 *   An array of product IDs that will be included in the form.
 * @param $show_quantity
 *   Boolean indicating whether or not the quantity field should be shown;
 *     defaults to FALSE resulting in a hidden field.
 * @param $default_quantity
 *   The value to place in the quantity field, defaults to 1.
 * @param $context
 *   Information on the context of the form's placement, allowing it to update
 *     product fields on the page based on the currently selected default
 *     product. Should be an associative array containing the following keys:
 *     - class_prefix: a prefix used to target HTML containers for replacement
 *       with rendered fields as the default product is updated. For example,
 *       nodes display product fields in their context wrapped in spans with the
 *       class node-#-product-field_name.  The class_prefix for the add to cart
 *       form displayed on a node would be node-# with this form's AJAX refresh
 *       adding the suffix -product-field_name.
 *     - view_mode: a product view mode that tells the AJAX refresh how to
 *       render the replacement fields.
 *     If no context is specified, AJAX replacement of rendered fields will not
 *     happen. This parameter only affects forms containing multiple products.
 *
 * @return
 *   The form array.
 */
function commerce_cart_add_to_cart_form($form, &$form_state, $product_ids, $show_quantity = FALSE, $default_quantity = 1, $context = array()) {
  global $user;

  // Store the form ID as a class of the form to avoid the incrementing form ID
  // from causing the AJAX refresh not to work.
  $form['#attributes']['class'][] = drupal_html_class(commerce_cart_add_to_cart_form_id($product_ids, $default_quantity));

  // Store the customer uid in the form so other modules can override with a
  // selection widget if necessary.
  $form['uid'] = array(
    '#type' => 'value',
    '#value' => $user->uid,
  );

  // Load all the products intended for sale on this form.
  $products = commerce_product_load_multiple($product_ids);

  // If no products were returned...
  if (count($products) == 0) {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Product not available'),
      '#disabled' => TRUE,
    );
  }
  else {
    $form_state['products'] = $products;

    // If the form is for a single product, store the product_id in a hidden
    // form field for use by the submit handler.
    if (count($products) == 1) {
      $form['product_id'] = array(
        '#type' => 'hidden',
        '#value' => key($products),
      );
    }
    else {
      // However, if more than one products are represented on it, attempt to
      // use smart select boxes for the product selection. If the products are
      // all of the same type and there are qualifying fields on that product
      // type, display their options for customer selection.
      $same_type = TRUE;
      $qualifying_fields = array();
      $type = '';

      // Find the default product so we know how to set default options on the
      // various Add to Cart form widgets and an array of any matching product
      // based on attribute selections so we can add a selection widget.
      $matching_products = array();
      $default_product = NULL;
      $attribute_names = array();
      $unchanged_attributes = array();

      foreach ($products as $product_id => $product) {
        // Store the first product type.
        if (empty($type)) {
          $type = $product->type;
        }

        // If the current product type is different from the first, we are not
        // dealing with a set of same typed products.
        if ($product->type != $type) {
          $same_type = FALSE;
        }

        // If the form state contains a set of attribute data, use it to try
        // and determine the default product.
        $changed_attribute = NULL;

        if (!empty($form_state['values']['attributes'])) {
          $match = TRUE;

          // Set an array of checked attributes for later comparison against the
          // default matching product.
          if (empty($attribute_names)) {
            $attribute_names = (array) array_diff_key($form_state['values']['attributes'], array('product_select' => ''));
            $unchanged_attributes = $form_state['values']['unchanged_attributes'];
          }

          foreach ($attribute_names as $key => $value) {
            // If this is the attribute widget that was changed...
            if ($value != $unchanged_attributes[$key]) {
              // Store the field name.
              $changed_attribute = $key;
            }

            // If a field name has been stored and we've moved past it to
            // compare the next attribute field...
            if (!empty($changed_attribute) && $changed_attribute != $key) {
              // Wipe subsequent values from the form state so the attribute
              // widgets can use the default values from the new default product.
              unset($form_state['input']['attributes'][$key]);

              // Don't accept this as a matching product.
              continue;
            }

            if ($product->{$key}[LANGUAGE_NONE][0]['value'] != $value) {
              $match = FALSE;
            }
          }

          // If the changed field name has already been stored, only accept the
          // first matching product by ignoring the rest that would match. An
          // exception is granted for additional matching products that share
          // the exact same attribute values as the first.
          if ($match && !empty($changed_attribute) && !empty($matching_products)) {
            reset($matching_products);
            $matching_product = $matching_products[key($matching_products)];

            foreach ($attribute_names as $key => $value) {
              if ($product->{$key}[LANGUAGE_NONE][0]['value'] != $matching_product->{$key}[LANGUAGE_NONE][0]['value']) {
                $match = FALSE;
              }
            }
          }

          if ($match) {
            $matching_products[$product_id] = $product;
          }
        }
      }

      // Set the default product now if it isn't already set.
      if (empty($matching_products)) {
        // If a product ID value was passed in, use that product if it exists.
        if (!empty($form_state['values']['product_id']) &&
            !empty($products[$form_state['values']['product_id']])) {
          $default_product = $products[$form_state['values']['product_id']];
        }
        else {
          reset($products);
          $default_product = $products[key($products)];
        }
      }
      else {
        // If the product selector has a value, use that.
        if (!empty($form_state['values']['attributes']['product_select']) &&
            !empty($products[$form_state['values']['attributes']['product_select']]) &&
            in_array($products[$form_state['values']['attributes']['product_select']], $matching_products)) {
          $default_product = $products[$form_state['values']['attributes']['product_select']];
        }
        else {
          reset($matching_products);
          $default_product = $matching_products[key($matching_products)];
        }
      }

      $form_state['default_product'] = $default_product;
      $form_state['context'] = $context;

      // If all the products are of the same type...
      if ($same_type) {
        // Loop through all the field instances on that product type.
        foreach (field_info_instances('commerce_product', $type) as $name => $instance) {
          // A field qualifies if it is single value, required and uses a widget
          // with a definite set of options. For the sake of simplicity, this is
          // currently restricted to fields defined by the options module.
          // Currently product attribute fields cannot be translatable either.
          $field = field_info_field($instance['field_name']);

          if ($field['cardinality'] == 1 && $instance['required'] && $instance['widget']['module'] == 'options' && empty($field['translatable'])) {
            // Get the options properties from the options module and store the
            // options for the instance in select list format in the array of
            // qualifying fields.
            $properties = _options_properties('select', FALSE, TRUE, TRUE);

            $qualifying_fields[$name] = array(
              'field' => $field,
              'instance' => $instance,
              'options' => _options_get_options($field, $instance, $properties),
              'weight' => $instance['widget']['weight'],
            );
          }
        }
      }

      // Otherwise for products of varying types, display a simple select list
      // by product title.
      if (!empty($qualifying_fields)) {
        $used_options = array();

        // Sort the fields by weight.
        uasort($qualifying_fields, 'drupal_sort_weight');

        foreach ($qualifying_fields as $field_name => $data) {
          // Build an options array of widget options used by referenced products.
          foreach ($products as $product_id => $product) {
            // Only add options to the present array that appear on products that
            // match the default value of the previously added attribute widgets.
            foreach ($used_options as $used_field_name => $unused) {
              // Don't apply this check for the current field being evaluated.
              if ($used_field_name == $field_name) {
                continue;
              }

              if ($product->{$used_field_name}[LANGUAGE_NONE][0]['value'] != $form['attributes'][$used_field_name]['#default_value']) {
                continue 2;
              }
            }

            // With our hard dependency on widgets provided by the Options
            // module, we can make assumptions about where the data is stored.
            $used_options[$field_name][] = $product->{$field_name}[LANGUAGE_NONE][0]['value'];
          }

          // If for some reason no options for this field are used, remove it
          // from the qualifying fields array.
          if (empty($used_options[$field_name])) {
            unset($qualifying_fields[$field_name]);
          }
          else {
            $form['attributes'][$field_name] = array(
              '#type' => 'select',
              '#title' => check_plain($data['instance']['label']),
              '#options' => array_intersect_key($data['options'], drupal_map_assoc($used_options[$field_name])),
              '#default_value' => $default_product->{$field_name}[LANGUAGE_NONE][0]['value'],
              '#weight' => $data['instance']['widget']['weight'],
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
            $form['unchanged_attributes'][$field_name] = array(
              '#type' => 'value',
              '#value' => $default_product->{$field_name}[LANGUAGE_NONE][0]['value'],
            );
          }
        }

        if (!empty($form['attributes'])) {
          $form['attributes'] += array(
            '#tree' => 'TRUE',
            '#prefix' => '<div class="attribute-widgets">',
            '#suffix' => '</div>',
            '#weight' => 0,
          );
          $form['unchanged_attributes'] += array(
            '#tree' => 'TRUE',
          );

          // If the matching products array is empty, it means this is the first
          // time the form is being built. We should populate it now with
          // products that match the default attribute options.
          if (empty($matching_products)) {
            foreach ($products as $product_id => $product) {
              $match = TRUE;

              foreach (element_children($form['attributes']) as $field_name) {
                if ($product->{$field_name}[LANGUAGE_NONE][0]['value'] != $form['attributes'][$field_name]['#default_value']) {
                  $match = FALSE;
                }
              }

              if ($match) {
                $matching_products[$product_id] = $product;
              }
            }
          }

          // If there were more than one matching products for the current
          // attribute selection, add a product selection widget.
          if (count($matching_products) > 1) {
            $options = array();

            foreach ($matching_products as $product_id => $product) {
              $options[$product_id] = check_plain($product->title);
            }

            $form['attributes']['product_select'] = array(
              '#type' => 'select',
              '#title' => t('Select a product'),
              '#options' => $options,
              '#default_value' => $default_product->product_id,
              '#weight' => 40,
              '#ajax' => array(
                'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
              ),
            );
          }

          $form['product_id'] = array(
            '#type' => 'hidden',
            '#value' => $default_product->product_id,
          );
        }
      }

      // If the products referenced were of different types or did not posess
      // any qualifying attribute fields, add a product selection widget.
      if (!$same_type || empty($qualifying_fields)) {
        $options = array();

        foreach ($products as $product_id => $product) {
          $options[$product_id] = check_plain($product->title);
        }

        $form['product_id'] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => $default_product->product_id,
          '#weight' => 0,
          '#ajax' => array(
            'callback' => 'commerce_cart_add_to_cart_form_attributes_refresh',
          ),
        );
      }
    }

    // Render the quantity field as either a textfield if shown or a hidden
    // field if not.
    if ($show_quantity) {
      $form['quantity'] = array(
        '#type' => 'textfield',
        '#title' => t('Quantity'),
        '#default_value' => $default_quantity,
        '#size' => 5,
        '#weight' => 5,
      );
    }
    else {
      $form['quantity'] = array(
        '#type' => 'hidden',
        '#value' => $default_quantity,
        '#weight' => 5,
      );
    }

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Add to cart'),
      '#weight' => 10,
    );
  }

  // Add the handlers manually since we're using hook_forms() to associate this
  // form with form IDs based on the $product_ids.
  $form['#validate'][] = 'commerce_cart_add_to_cart_form_validate';
  $form['#submit'][] = 'commerce_cart_add_to_cart_form_submit';

  return $form;
}

/**
 * Form validate handler: validate the product and quantity to add to the cart.
 */
function commerce_cart_add_to_cart_form_validate($form, &$form_state) {
  if (!is_numeric($form_state['values']['quantity']) || $form_state['values']['quantity'] <= 0) {
    form_set_error('quantity', t('You must specify a valid quantity to add to the cart.'));
  }

  // If the attributes matching product selector was used, set the value of the
  // product_id field to match; this will be fixed on rebuild when the actual
  // default product will be selected based on the product selector value.
  if (!empty($form_state['values']['attributes']['product_select'])) {
    form_set_value($form['product_id'], $form_state['values']['attributes']['product_select'], $form_state);
  }
}

/**
 * Ajax callback: returns AJAX commands when an attribute widget is changed.
 */
function commerce_cart_add_to_cart_form_attributes_refresh($form, $form_state) {
  $commands = array();

  // Render the form afresh to capture any changes to the available widgets
  // based on the latest selection.
  $commands[] = ajax_command_replace('.' . drupal_html_class($form['#form_id']), drupal_render($form));

  // Then render and return the various product fields that might need to be
  // updated on the page.
  if (!empty($form_state['context'])) {
    $product = $form_state['default_product'];

    foreach (field_info_instances('commerce_product', $product->type) as $product_field_name => $product_field) {
      $class = drupal_html_class(implode('-', array($form_state['context']['class_prefix'], 'product', $product_field_name)));

      $element = field_view_field('commerce_product', $product, $product_field_name, $form_state['context']['view_mode']);
      $element += array(
        '#prefix' => '<span class="' . $class . '">',
        '#suffix' => '</span>',
      );

      $commands[] = ajax_command_replace('.' . $class, drupal_render($element));
    }
  }

  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Form submit handler: add the selected product to the cart.
 */
function commerce_cart_add_to_cart_form_submit($form, &$form_state) {
  $product_id = $form_state['values']['product_id'];
  $product = $form_state['products'][$product_id];

  // Add the product to the specified shopping cart.
  commerce_cart_product_add($form_state['values']['uid'], $product_id, $form_state['values']['quantity']);

  // TODO: Accommodate multiple product Add to Cart forms better; i.e. should it
  // display the product title or the product display node title?
  drupal_set_message(t('%title added to <a href="!cart-url">your cart</a>.', array('%title' => $product->title, '!cart-url' => url('cart'))));
}

/**
 * Implements hook_field_info_alter().
 */
function commerce_cart_field_info_alter(&$info) {
  // Set the default display formatter for product reference fields to the Add
  // to Cart form.
  $info['commerce_product_reference']['default_formatter'] = 'commerce_cart_add_to_cart_form';
}

/**
 * Implements hook_field_formatter_info().
 */
function commerce_cart_field_formatter_info() {
  return array(
    'commerce_cart_add_to_cart_form' => array(
      'label' => t('Add to Cart form'),
      'description' => t('Display an Add to Cart form for the referenced product.'),
      'field types' => array('commerce_product_reference'),
      'settings' => array(
        'show_quantity' => FALSE,
        'default_quantity' => 1,
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function commerce_cart_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $element['show_quantity'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display a textfield quantity widget on the add to cart form.'),
      '#default_value' => $settings['show_quantity'],
    );

    $element['default_quantity'] = array(
      '#type' => 'textfield',
      '#title' => t('Default quantity'),
      '#default_value' => $settings['default_quantity'] <= 0 ? 1 : $settings['default_quantity'],
      '#element_validate' => array('commerce_cart_field_formatter_settings_form_quantity_validate'),
      '#size' => 16,
    );
  }

  return $element;
}

/**
 * Element validate callback: ensure a valid quantity is entered.
 */
function commerce_cart_field_formatter_settings_form_quantity_validate($element, &$form_state, $form) {
  if (!is_numeric($element['#value']) || $element['#value'] <= 0) {
    form_set_error(implode('][', $element['#parents']), t('You must enter a positive numeric default quantity value.'));
  }
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function commerce_cart_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $summary = array(
      t('Quantity widget: !status', array('!status' => $settings['show_quantity'] ? t('Enabled') : t('Disabled'))),
      t('Default quantity: @quantity', array('@quantity' => $settings['default_quantity'])),
    );
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function commerce_cart_field_formatter_view($entity_type, $object, $field, $instance, $langcode, $items, $display) {
  $result = array();

  // Collect the list of product IDs.
  $product_ids = array();

  foreach ($items as $delta => $item) {
    $product_ids[$item['product_id']] = $item['product_id'];
  }

  if ($display['type'] == 'commerce_cart_add_to_cart_form') {
    $settings = $display['settings'];

    $result[] = array(
      '#arguments' => array(
        'form_id' => commerce_cart_add_to_cart_form_id($product_ids),
        'product_ids' => $product_ids,
        'show_quantity' => $settings['show_quantity'],
        'default_quantity' => $settings['default_quantity'],
      ),
    );
  }

  return $result;
}

/**
 * Implements hook_field_attach_view_alter().
 *
 * When a field is formatted for display, the display formatter does not know
 * what view mode it is being displayed for. Unfortunately, the Add to Cart form
 * display formatter needs this information when displaying product reference
 * fields on nodes to provide adequate context for product field replacement on
 * multi-value product reference fields. This hook is used to transform a set of
 * arguments into a form using the arguments and the extra context information
 * gleaned from the parameters passed into this function.
 */
function commerce_cart_field_attach_view_alter(&$output, $context) {
  // Loop through the fields passed in looking for any product reference fields
  // formatted with the Add to Cart form display formatter.
  foreach ($output as $field_name => $element) {
    if (!empty($element['#formatter']) && $element['#formatter'] == 'commerce_cart_add_to_cart_form') {
      // Prepare the context information needed by the cart form.
      $context = array();

      // Add the context for displaying product fields in the context of a node
      // that references the product by looking at the entity this product
      // reference field is attached to.
      if ($element['#entity_type'] == 'node') {
        $context = array(
          'class_prefix' => 'node-' . $element['#object']->nid,
          'view_mode' => 'node_' . $element['#view_mode'],
        );
      }

      foreach (element_children($element) as $key) {
        // Extract the drupal_get_form() arguments array from the element.
        $arguments = $element[$key]['#arguments'];

        // Replace the array containing the arguments with the return value of
        // drupal_get_form(). It will be rendered when the rest of the object is
        // rendered for display.
        $output[$field_name][$key] = drupal_get_form($arguments['form_id'], $arguments['product_ids'], $arguments['show_quantity'], $arguments['default_quantity'], $context);
      }
    }
  }
}
